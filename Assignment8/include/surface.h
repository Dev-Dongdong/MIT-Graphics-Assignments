/*
 * @Description: Two types of surfaces
 * @Author: LvBujing
 * @Date: 2021-03-09 12:45:46
 * @LastEditTime: 2021-03-11 16:58:35
 * @LastEditors: LvBujing
 */
#ifndef _SURFACE_H_
#define _SURFACE_H_

#include "spline.h"
#include "curve.h"

#define MY_PI 3.14159265
//  Another type of Spline, and the base class of Surface
class Surface : public Spline {

private:
    /* data */
public:
    Surface(/* args */) { }
    ~Surface() { }
};




//  A type of Surface, which made of revolution of Curve around Y axis
class SurfaceOfRevolution : public Surface {

private:
    Curve *c;
public:
    SurfaceOfRevolution(Curve *_c) : c(_c) { } 
    ~SurfaceOfRevolution() { }

    //  While SurfaceOfRevolution has no vertices information, all below func need call Curve c's.
    void Paint (ArgParser *args) { c->Paint(args); }
    void moveControlPoint(int selectedPoint, float x, float y) { c->moveControlPoint(selectedPoint,x,y); }
    void addControlPoint(int selectedPoint, float x, float y) { c->addControlPoint(selectedPoint,x,y); }
    void deleteControlPoint(int selectedPoint) { c->deleteControlPoint(selectedPoint); }
    int getNumVertices() { return c->getNumVertices(); }
    Vec3f getVertex(int i) { return c->getVertex(i); }
    void OutputBezier(FILE *file) { fprintf(file,"surface_of_revolution\n"); c->OutputBezier(file); }
    void OutputBSpline(FILE *file) { fprintf(file,"surface_of_revolution\n"); c->OutputBSpline(file); }
    //  Generate trianglemesh for saving to obj format
    //  For SurfaceOfRevolution class, the trianglemesh 
    //  should be generated by curve rotate around the Y axis
    TriangleMesh* OutputTriangles(ArgParser *args) { 
        int tessellation = args->revolution_tessellation;   //  How many parts should the whole ring divided to
        int curve_tess = args->curve_tessellation;
        TriangleMesh* m = new TriangleMesh(0,0);
        
        float theta = 2 * MY_PI / (float)tessellation;
        Matrix rotate;

        Vec3f pre_pos,rot_pre_pos,next_pos,rot_next_pos;
        int control_point_index = 0;
        int interval = c->getInterval();
        
        for (int i = 0; i < tessellation; i++) {    //  Each Segment
            control_point_index = 0;
            while (control_point_index + 3 < getNumVertices()) {
                for (int j = 0; j < curve_tess; j++) { //  Each point pair
                    //  TODO: Obtain the correct vertex in world position.
                    //  You may achieve a func for curve: Given t of whole curve, return a Vec3f IN curve(Not in control point)
                    //  ATTENTION: the curve_tess indicate that every 4 points bezier should be divided to curve_tess num pieces
                    pre_pos = c->getVertexInCurve(control_point_index, (float)j / curve_tess);
                    rot_pre_pos = pre_pos;
                    
                    next_pos = c->getVertexInCurve(control_point_index, (float)(j+1) / curve_tess);
                    rot_next_pos = next_pos;
                    rotate = Matrix::MakeYRotation(i * theta);
                    rotate.Transform(pre_pos);
                    rotate.Transform(next_pos);
                    rotate = Matrix::MakeYRotation((i + 1) * theta);
                    rotate.Transform(rot_pre_pos);
                    rotate.Transform(rot_next_pos);
                    TriangleNet rectangle = TriangleNet(1,1);
                    rectangle.SetVertex(0,0,pre_pos);
                    rectangle.SetVertex(0,1,next_pos);
                    rectangle.SetVertex(1,0,rot_pre_pos);
                    rectangle.SetVertex(1,1,rot_next_pos);
                    m->Merge(rectangle);
                }
                control_point_index += interval;
            }
        }
        return m;
    }
};

//  A type of Surface, which made of 4X4 Bicubic Bezier Patch
class BezierPatch : public Surface {
    
private:
    BezierCurve* beziers;
public:
    BezierPatch() { beziers = new BezierCurve [4]; }
    ~BezierPatch() { delete [] beziers; }
    
    //  Disable the edit for BezierPatch
    int getNumVertices() { return 0; }
    Vec3f getVertex(int i) { return Vec3f(0,0,0); }
    void moveControlPoint(int selectedPoint, float x, float y) {  }
    void addControlPoint(int selectedPoint, float x, float y) {  }
    void deleteControlPoint(int selectedPoint) {  }
    
    //   Set the points of 4 beziers
    void set(int &i, Vec3f &v) const { 
        int index = i % 4;
        beziers[i / 4].set(index,v);
    }

    //  Paint all points and lines  (Not paint bezier [Green] )
    void Paint(ArgParser *args) { 
        for (int i = 0; i < 4; i++) {
            beziers[i].Curve::Paint(args);
            beziers[i].drawControlPoints();
        }
    }

    //  Generate trianglemesh for saving to obj format
    //  For BezierPatch class, the trianglemesh 
    //  should be generated by Double Bezier transform
    TriangleMesh* OutputTriangles(ArgParser *args) { 
        int tessellation = args->patch_tessellation;   //  How many little part should every bezier divided to
        TriangleMesh* m = new TriangleMesh(0,0);
        TriangleNet net = TriangleNet(tessellation,tessellation);
        BezierCurve* c;
        Vec3f point,point2th;
        //  Come to the First Bezier Transform
        for (int i = 0; i <= tessellation; i++) {
            c = new BezierCurve();
            for (int j = 0; j < 4; j++) {
                point = beziers[j].getVertexInCurve(0, (float)i / tessellation);
                c->set(j,point);
            }
            //  Come to the Second Bezier Transform
            for (int k = 0; k <= tessellation; k++) {
                point2th = c->getVertexInCurve(0, (float)k / tessellation);
                net.SetVertex(i,k,point2th);
            }
        }
        m->Merge(net);
        return m;
    }
};

#endif

